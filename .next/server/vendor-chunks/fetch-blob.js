/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fetch-blob";
exports.ids = ["vendor-chunks/fetch-blob"];
exports.modules = {

/***/ "(rsc)/./node_modules/fetch-blob/streams.cjs":
/*!*********************************************!*\
  !*** ./node_modules/fetch-blob/streams.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* c8 ignore start */ // 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\nif (!globalThis.ReadableStream) {\n    // `node:stream/web` got introduced in v16.5.0 as experimental\n    // and it's preferred over the polyfilled version. So we also\n    // suppress the warning that gets emitted by NodeJS for using it.\n    try {\n        const process = __webpack_require__(/*! node:process */ \"node:process\");\n        const { emitWarning } = process;\n        try {\n            process.emitWarning = ()=>{};\n            Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ \"node:stream/web\"));\n            process.emitWarning = emitWarning;\n        } catch (error) {\n            process.emitWarning = emitWarning;\n            throw error;\n        }\n    } catch (error) {\n        // fallback to polyfill implementation\n        Object.assign(globalThis, __webpack_require__(/*! web-streams-polyfill/dist/ponyfill.es2018.js */ \"(rsc)/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\"));\n    }\n}\ntry {\n    // Don't use node: prefix for this, require+node: is not supported until node v14.14\n    // Only `import()` can use prefix in 12.20 and later\n    const { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    if (Blob && !Blob.prototype.stream) {\n        Blob.prototype.stream = function name(params) {\n            let position = 0;\n            const blob = this;\n            return new ReadableStream({\n                type: \"bytes\",\n                async pull (ctrl) {\n                    const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE));\n                    const buffer = await chunk.arrayBuffer();\n                    position += buffer.byteLength;\n                    ctrl.enqueue(new Uint8Array(buffer));\n                    if (position === blob.size) {\n                        ctrl.close();\n                    }\n                }\n            });\n        };\n    }\n} catch (error) {} /* c8 ignore end */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9zdHJlYW1zLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsR0FDbkIsZ0VBQWdFO0FBQ2hFLE1BQU1BLFlBQVk7QUFFbEIsSUFBSSxDQUFDQyxXQUFXQyxjQUFjLEVBQUU7SUFDOUIsOERBQThEO0lBQzlELDZEQUE2RDtJQUM3RCxpRUFBaUU7SUFDakUsSUFBSTtRQUNGLE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDO1FBQ3hCLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdGO1FBQ3hCLElBQUk7WUFDRkEsUUFBUUUsV0FBVyxHQUFHLEtBQU87WUFDN0JDLE9BQU9DLE1BQU0sQ0FBQ04sWUFBWUcsbUJBQU9BLENBQUM7WUFDbENELFFBQVFFLFdBQVcsR0FBR0E7UUFDeEIsRUFBRSxPQUFPRyxPQUFPO1lBQ2RMLFFBQVFFLFdBQVcsR0FBR0E7WUFDdEIsTUFBTUc7UUFDUjtJQUNGLEVBQUUsT0FBT0EsT0FBTztRQUNkLHNDQUFzQztRQUN0Q0YsT0FBT0MsTUFBTSxDQUFDTixZQUFZRyxtQkFBT0EsQ0FBQztJQUNwQztBQUNGO0FBRUEsSUFBSTtJQUNGLG9GQUFvRjtJQUNwRixvREFBb0Q7SUFDcEQsTUFBTSxFQUFFSyxJQUFJLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7SUFDekIsSUFBSUssUUFBUSxDQUFDQSxLQUFLQyxTQUFTLENBQUNDLE1BQU0sRUFBRTtRQUNsQ0YsS0FBS0MsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU0MsS0FBTUMsTUFBTTtZQUMzQyxJQUFJQyxXQUFXO1lBQ2YsTUFBTUMsT0FBTyxJQUFJO1lBRWpCLE9BQU8sSUFBSWIsZUFBZTtnQkFDeEJjLE1BQU07Z0JBQ04sTUFBTUMsTUFBTUMsSUFBSTtvQkFDZCxNQUFNQyxRQUFRSixLQUFLSyxLQUFLLENBQUNOLFVBQVVPLEtBQUtDLEdBQUcsQ0FBQ1AsS0FBS1EsSUFBSSxFQUFFVCxXQUFXZDtvQkFDbEUsTUFBTXdCLFNBQVMsTUFBTUwsTUFBTU0sV0FBVztvQkFDdENYLFlBQVlVLE9BQU9FLFVBQVU7b0JBQzdCUixLQUFLUyxPQUFPLENBQUMsSUFBSUMsV0FBV0o7b0JBRTVCLElBQUlWLGFBQWFDLEtBQUtRLElBQUksRUFBRTt3QkFDMUJMLEtBQUtXLEtBQUs7b0JBQ1o7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFDRixFQUFFLE9BQU9yQixPQUFPLENBQUMsRUFDakIsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0Y2FwLWRpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL3N0cmVhbXMuY2pzPzUzNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogYzggaWdub3JlIHN0YXJ0ICovXG4vLyA2NCBLaUIgKHNhbWUgc2l6ZSBjaHJvbWUgc2xpY2UgdGhlaXJzIGJsb2IgaW50byBVaW50OGFycmF5J3MpXG5jb25zdCBQT09MX1NJWkUgPSA2NTUzNlxuXG5pZiAoIWdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0pIHtcbiAgLy8gYG5vZGU6c3RyZWFtL3dlYmAgZ290IGludHJvZHVjZWQgaW4gdjE2LjUuMCBhcyBleHBlcmltZW50YWxcbiAgLy8gYW5kIGl0J3MgcHJlZmVycmVkIG92ZXIgdGhlIHBvbHlmaWxsZWQgdmVyc2lvbi4gU28gd2UgYWxzb1xuICAvLyBzdXBwcmVzcyB0aGUgd2FybmluZyB0aGF0IGdldHMgZW1pdHRlZCBieSBOb2RlSlMgZm9yIHVzaW5nIGl0LlxuICB0cnkge1xuICAgIGNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdub2RlOnByb2Nlc3MnKVxuICAgIGNvbnN0IHsgZW1pdFdhcm5pbmcgfSA9IHByb2Nlc3NcbiAgICB0cnkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyA9ICgpID0+IHt9XG4gICAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHJlcXVpcmUoJ25vZGU6c3RyZWFtL3dlYicpKVxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyA9IGVtaXRXYXJuaW5nXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSBlbWl0V2FybmluZ1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gcG9seWZpbGwgaW1wbGVtZW50YXRpb25cbiAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHJlcXVpcmUoJ3dlYi1zdHJlYW1zLXBvbHlmaWxsL2Rpc3QvcG9ueWZpbGwuZXMyMDE4LmpzJykpXG4gIH1cbn1cblxudHJ5IHtcbiAgLy8gRG9uJ3QgdXNlIG5vZGU6IHByZWZpeCBmb3IgdGhpcywgcmVxdWlyZStub2RlOiBpcyBub3Qgc3VwcG9ydGVkIHVudGlsIG5vZGUgdjE0LjE0XG4gIC8vIE9ubHkgYGltcG9ydCgpYCBjYW4gdXNlIHByZWZpeCBpbiAxMi4yMCBhbmQgbGF0ZXJcbiAgY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdidWZmZXInKVxuICBpZiAoQmxvYiAmJiAhQmxvYi5wcm90b3R5cGUuc3RyZWFtKSB7XG4gICAgQmxvYi5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24gbmFtZSAocGFyYW1zKSB7XG4gICAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgICBjb25zdCBibG9iID0gdGhpc1xuXG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgYXN5bmMgcHVsbCAoY3RybCkge1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gYmxvYi5zbGljZShwb3NpdGlvbiwgTWF0aC5taW4oYmxvYi5zaXplLCBwb3NpdGlvbiArIFBPT0xfU0laRSkpXG4gICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY2h1bmsuYXJyYXlCdWZmZXIoKVxuICAgICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgY3RybC5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpXG5cbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09IGJsb2Iuc2l6ZSkge1xuICAgICAgICAgICAgY3RybC5jbG9zZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSBjYXRjaCAoZXJyb3IpIHt9XG4vKiBjOCBpZ25vcmUgZW5kICovXG4iXSwibmFtZXMiOlsiUE9PTF9TSVpFIiwiZ2xvYmFsVGhpcyIsIlJlYWRhYmxlU3RyZWFtIiwicHJvY2VzcyIsInJlcXVpcmUiLCJlbWl0V2FybmluZyIsIk9iamVjdCIsImFzc2lnbiIsImVycm9yIiwiQmxvYiIsInByb3RvdHlwZSIsInN0cmVhbSIsIm5hbWUiLCJwYXJhbXMiLCJwb3NpdGlvbiIsImJsb2IiLCJ0eXBlIiwicHVsbCIsImN0cmwiLCJjaHVuayIsInNsaWNlIiwiTWF0aCIsIm1pbiIsInNpemUiLCJidWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJlbnF1ZXVlIiwiVWludDhBcnJheSIsImNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/streams.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/fetch-blob/file.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/file.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   File: () => (/* binding */ File),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/fetch-blob/index.js\");\n\nconst _File = class File extends _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    #lastModified;\n    #name;\n    /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */ // @ts-ignore\n    constructor(fileBits, fileName, options = {}){\n        if (arguments.length < 2) {\n            throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);\n        }\n        super(fileBits, options);\n        this.#lastModified = 0;\n        this.#name = \"\";\n        if (options === null) options = {};\n        // Simulate WebIDL type casting for NaN value in lastModified option.\n        const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);\n        if (!Number.isNaN(lastModified)) {\n            this.#lastModified = lastModified;\n        }\n        this.#name = String(fileName);\n    }\n    get name() {\n        return this.#name;\n    }\n    get lastModified() {\n        return this.#lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n    static [Symbol.hasInstance](object) {\n        return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] && /^(File)$/.test(object[Symbol.toStringTag]);\n    }\n};\n/** @type {typeof globalThis.File} */ // @ts-ignore\nconst File = _File;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (File);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9maWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUU3QixNQUFNQyxRQUFRLE1BQU1DLGFBQWFGLGlEQUFJQTtJQUNuQyxDQUFDRyxZQUFZLENBQUk7SUFDakIsQ0FBQ0MsSUFBSSxDQUFLO0lBRVY7Ozs7R0FJQyxHQUFFLGFBQWE7SUFDaEJDLFlBQWFDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQzdDLElBQUlDLFVBQVVDLE1BQU0sR0FBRyxHQUFHO1lBQ3hCLE1BQU0sSUFBSUMsVUFBVSxDQUFDLDJEQUEyRCxFQUFFRixVQUFVQyxNQUFNLENBQUMsU0FBUyxDQUFDO1FBQy9HO1FBQ0EsS0FBSyxDQUFDSixVQUFVRTthQVpsQixDQUFDTCxZQUFZLEdBQUc7YUFDaEIsQ0FBQ0MsSUFBSSxHQUFHO1FBYU4sSUFBSUksWUFBWSxNQUFNQSxVQUFVLENBQUM7UUFFakMscUVBQXFFO1FBQ3JFLE1BQU1MLGVBQWVLLFFBQVFMLFlBQVksS0FBS1MsWUFBWUMsS0FBS0MsR0FBRyxLQUFLQyxPQUFPUCxRQUFRTCxZQUFZO1FBQ2xHLElBQUksQ0FBQ1ksT0FBT0MsS0FBSyxDQUFDYixlQUFlO1lBQy9CLElBQUksQ0FBQyxDQUFDQSxZQUFZLEdBQUdBO1FBQ3ZCO1FBRUEsSUFBSSxDQUFDLENBQUNDLElBQUksR0FBR2EsT0FBT1Y7SUFDdEI7SUFFQSxJQUFJSCxPQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtJQUNuQjtJQUVBLElBQUlELGVBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLENBQUNBLFlBQVk7SUFDM0I7SUFFQSxJQUFJLENBQUNlLE9BQU9DLFdBQVcsQ0FBQyxHQUFJO1FBQzFCLE9BQU87SUFDVDtJQUVBLE9BQU8sQ0FBQ0QsT0FBT0UsV0FBVyxDQUFDLENBQUVDLE1BQU0sRUFBRTtRQUNuQyxPQUFPLENBQUMsQ0FBQ0EsVUFBVUEsa0JBQWtCckIsaURBQUlBLElBQ3ZDLFdBQVdzQixJQUFJLENBQUNELE1BQU0sQ0FBQ0gsT0FBT0MsV0FBVyxDQUFDO0lBQzlDO0FBQ0Y7QUFFQSxtQ0FBbUMsR0FBRSxhQUFhO0FBQzNDLE1BQU1qQixPQUFPRCxNQUFLO0FBQ3pCLGlFQUFlQyxJQUFJQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0Y2FwLWRpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL2ZpbGUuanM/MjQ4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmxvYiBmcm9tICcuL2luZGV4LmpzJ1xuXG5jb25zdCBfRmlsZSA9IGNsYXNzIEZpbGUgZXh0ZW5kcyBCbG9iIHtcbiAgI2xhc3RNb2RpZmllZCA9IDBcbiAgI25hbWUgPSAnJ1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geypbXX0gZmlsZUJpdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVOYW1lXG4gICAqIEBwYXJhbSB7e2xhc3RNb2RpZmllZD86IG51bWJlciwgdHlwZT86IHN0cmluZ319IG9wdGlvbnNcbiAgICovLy8gQHRzLWlnbm9yZVxuICBjb25zdHJ1Y3RvciAoZmlsZUJpdHMsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ0ZpbGUnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmApXG4gICAgfVxuICAgIHN1cGVyKGZpbGVCaXRzLCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwpIG9wdGlvbnMgPSB7fVxuXG4gICAgLy8gU2ltdWxhdGUgV2ViSURMIHR5cGUgY2FzdGluZyBmb3IgTmFOIHZhbHVlIGluIGxhc3RNb2RpZmllZCBvcHRpb24uXG4gICAgY29uc3QgbGFzdE1vZGlmaWVkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgPT09IHVuZGVmaW5lZCA/IERhdGUubm93KCkgOiBOdW1iZXIob3B0aW9ucy5sYXN0TW9kaWZpZWQpXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obGFzdE1vZGlmaWVkKSkge1xuICAgICAgdGhpcy4jbGFzdE1vZGlmaWVkID0gbGFzdE1vZGlmaWVkXG4gICAgfVxuXG4gICAgdGhpcy4jbmFtZSA9IFN0cmluZyhmaWxlTmFtZSlcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy4jbmFtZVxuICB9XG5cbiAgZ2V0IGxhc3RNb2RpZmllZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0ZpbGUnXG4gIH1cblxuICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0gKG9iamVjdCkge1xuICAgIHJldHVybiAhIW9iamVjdCAmJiBvYmplY3QgaW5zdGFuY2VvZiBCbG9iICYmXG4gICAgICAvXihGaWxlKSQvLnRlc3Qob2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10pXG4gIH1cbn1cblxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5GaWxlfSAqLy8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBGaWxlID0gX0ZpbGVcbmV4cG9ydCBkZWZhdWx0IEZpbGVcbiJdLCJuYW1lcyI6WyJCbG9iIiwiX0ZpbGUiLCJGaWxlIiwibGFzdE1vZGlmaWVkIiwibmFtZSIsImNvbnN0cnVjdG9yIiwiZmlsZUJpdHMiLCJmaWxlTmFtZSIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJ1bmRlZmluZWQiLCJEYXRlIiwibm93IiwiTnVtYmVyIiwiaXNOYU4iLCJTdHJpbmciLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImhhc0luc3RhbmNlIiwib2JqZWN0IiwidGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fetch-blob/from.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/from.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   File: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   blobFrom: () => (/* binding */ blobFrom),\n/* harmony export */   blobFromSync: () => (/* binding */ blobFromSync),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fileFrom: () => (/* binding */ fileFrom),\n/* harmony export */   fileFromSync: () => (/* binding */ fileFromSync)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_domexception__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-domexception */ \"(rsc)/./node_modules/node-domexception/index.js\");\n/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file.js */ \"(rsc)/./node_modules/fetch-blob/file.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/fetch-blob/index.js\");\n\n\n\n\n\nconst { stat } = node_fs__WEBPACK_IMPORTED_MODULE_0__.promises;\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */ const blobFromSync = (path, type)=>fromBlob((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type);\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */ const blobFrom = (path, type)=>stat(path).then((stat)=>fromBlob(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */ const fileFrom = (path, type)=>stat(path).then((stat)=>fromFile(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */ const fileFromSync = (path, type)=>fromFile((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type);\n// @ts-ignore\nconst fromBlob = (stat, path, type = \"\")=>new _index_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]([\n        new BlobDataItem({\n            path,\n            size: stat.size,\n            lastModified: stat.mtimeMs,\n            start: 0\n        })\n    ], {\n        type\n    });\n// @ts-ignore\nconst fromFile = (stat, path, type = \"\")=>new _file_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]([\n        new BlobDataItem({\n            path,\n            size: stat.size,\n            lastModified: stat.mtimeMs,\n            start: 0\n        })\n    ], (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(path), {\n        type,\n        lastModified: stat.mtimeMs\n    });\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */ class BlobDataItem {\n    #path;\n    #start;\n    constructor(options){\n        this.#path = options.path;\n        this.#start = options.start;\n        this.size = options.size;\n        this.lastModified = options.lastModified;\n    }\n    /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */ slice(start, end) {\n        return new BlobDataItem({\n            path: this.#path,\n            lastModified: this.lastModified,\n            size: end - start,\n            start: this.#start + start\n        });\n    }\n    async *stream() {\n        const { mtimeMs } = await stat(this.#path);\n        if (mtimeMs > this.lastModified) {\n            throw new node_domexception__WEBPACK_IMPORTED_MODULE_2__(\"The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.\", \"NotReadableError\");\n        }\n        yield* (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.createReadStream)(this.#path, {\n            start: this.#start,\n            end: this.#start + this.size - 1\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blobFromSync);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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L21hcmtldGNhcC1kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9mcm9tLmpzPzRmZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RhdFN5bmMsIGNyZWF0ZVJlYWRTdHJlYW0sIHByb21pc2VzIGFzIGZzIH0gZnJvbSAnbm9kZTpmcydcbmltcG9ydCB7IGJhc2VuYW1lIH0gZnJvbSAnbm9kZTpwYXRoJ1xuaW1wb3J0IERPTUV4Y2VwdGlvbiBmcm9tICdub2RlLWRvbWV4Y2VwdGlvbidcblxuaW1wb3J0IEZpbGUgZnJvbSAnLi9maWxlLmpzJ1xuaW1wb3J0IEJsb2IgZnJvbSAnLi9pbmRleC5qcydcblxuY29uc3QgeyBzdGF0IH0gPSBmc1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICovXG5jb25zdCBibG9iRnJvbVN5bmMgPSAocGF0aCwgdHlwZSkgPT4gZnJvbUJsb2Ioc3RhdFN5bmMocGF0aCksIHBhdGgsIHR5cGUpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9iPn1cbiAqL1xuY29uc3QgYmxvYkZyb20gPSAocGF0aCwgdHlwZSkgPT4gc3RhdChwYXRoKS50aGVuKHN0YXQgPT4gZnJvbUJsb2Ioc3RhdCwgcGF0aCwgdHlwZSkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlPn1cbiAqL1xuY29uc3QgZmlsZUZyb20gPSAocGF0aCwgdHlwZSkgPT4gc3RhdChwYXRoKS50aGVuKHN0YXQgPT4gZnJvbUZpbGUoc3RhdCwgcGF0aCwgdHlwZSkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXG4gKi9cbmNvbnN0IGZpbGVGcm9tU3luYyA9IChwYXRoLCB0eXBlKSA9PiBmcm9tRmlsZShzdGF0U3luYyhwYXRoKSwgcGF0aCwgdHlwZSlcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgZnJvbUJsb2IgPSAoc3RhdCwgcGF0aCwgdHlwZSA9ICcnKSA9PiBuZXcgQmxvYihbbmV3IEJsb2JEYXRhSXRlbSh7XG4gIHBhdGgsXG4gIHNpemU6IHN0YXQuc2l6ZSxcbiAgbGFzdE1vZGlmaWVkOiBzdGF0Lm10aW1lTXMsXG4gIHN0YXJ0OiAwXG59KV0sIHsgdHlwZSB9KVxuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmcm9tRmlsZSA9IChzdGF0LCBwYXRoLCB0eXBlID0gJycpID0+IG5ldyBGaWxlKFtuZXcgQmxvYkRhdGFJdGVtKHtcbiAgcGF0aCxcbiAgc2l6ZTogc3RhdC5zaXplLFxuICBsYXN0TW9kaWZpZWQ6IHN0YXQubXRpbWVNcyxcbiAgc3RhcnQ6IDBcbn0pXSwgYmFzZW5hbWUocGF0aCksIHsgdHlwZSwgbGFzdE1vZGlmaWVkOiBzdGF0Lm10aW1lTXMgfSlcblxuLyoqXG4gKiBUaGlzIGlzIGEgYmxvYiBiYWNrZWQgdXAgYnkgYSBmaWxlIG9uIHRoZSBkaXNrXG4gKiB3aXRoIG1pbml1bSByZXF1aXJlbWVudC4gSXRzIHdyYXBwZWQgYXJvdW5kIGEgQmxvYiBhcyBhIGJsb2JQYXJ0XG4gKiBzbyB5b3UgaGF2ZSBubyBkaXJlY3QgYWNjZXNzIHRvIHRoaXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQmxvYkRhdGFJdGVtIHtcbiAgI3BhdGhcbiAgI3N0YXJ0XG5cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICB0aGlzLiNwYXRoID0gb3B0aW9ucy5wYXRoXG4gICAgdGhpcy4jc3RhcnQgPSBvcHRpb25zLnN0YXJ0XG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplXG4gICAgdGhpcy5sYXN0TW9kaWZpZWQgPSBvcHRpb25zLmxhc3RNb2RpZmllZFxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWNpbmcgYXJndW1lbnRzIGlzIGZpcnN0IHZhbGlkYXRlZCBhbmQgZm9ybWF0dGVkXG4gICAqIHRvIG5vdCBiZSBvdXQgb2YgcmFuZ2UgYnkgQmxvYi5wcm90b3R5cGUuc2xpY2VcbiAgICovXG4gIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iRGF0YUl0ZW0oe1xuICAgICAgcGF0aDogdGhpcy4jcGF0aCxcbiAgICAgIGxhc3RNb2RpZmllZDogdGhpcy5sYXN0TW9kaWZpZWQsXG4gICAgICBzaXplOiBlbmQgLSBzdGFydCxcbiAgICAgIHN0YXJ0OiB0aGlzLiNzdGFydCArIHN0YXJ0XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jICogc3RyZWFtICgpIHtcbiAgICBjb25zdCB7IG10aW1lTXMgfSA9IGF3YWl0IHN0YXQodGhpcy4jcGF0aClcbiAgICBpZiAobXRpbWVNcyA+IHRoaXMubGFzdE1vZGlmaWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgcmVxdWVzdGVkIGZpbGUgY291bGQgbm90IGJlIHJlYWQsIHR5cGljYWxseSBkdWUgdG8gcGVybWlzc2lvbiBwcm9ibGVtcyB0aGF0IGhhdmUgb2NjdXJyZWQgYWZ0ZXIgYSByZWZlcmVuY2UgdG8gYSBmaWxlIHdhcyBhY3F1aXJlZC4nLCAnTm90UmVhZGFibGVFcnJvcicpXG4gICAgfVxuICAgIHlpZWxkICogY3JlYXRlUmVhZFN0cmVhbSh0aGlzLiNwYXRoLCB7XG4gICAgICBzdGFydDogdGhpcy4jc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuI3N0YXJ0ICsgdGhpcy5zaXplIC0gMVxuICAgIH0pXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xuICAgIHJldHVybiAnQmxvYidcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBibG9iRnJvbVN5bmNcbmV4cG9ydCB7IEZpbGUsIEJsb2IsIGJsb2JGcm9tLCBibG9iRnJvbVN5bmMsIGZpbGVGcm9tLCBmaWxlRnJvbVN5bmMgfVxuIl0sIm5hbWVzIjpbInN0YXRTeW5jIiwiY3JlYXRlUmVhZFN0cmVhbSIsInByb21pc2VzIiwiZnMiLCJiYXNlbmFtZSIsIkRPTUV4Y2VwdGlvbiIsIkZpbGUiLCJCbG9iIiwic3RhdCIsImJsb2JGcm9tU3luYyIsInBhdGgiLCJ0eXBlIiwiZnJvbUJsb2IiLCJibG9iRnJvbSIsInRoZW4iLCJmaWxlRnJvbSIsImZyb21GaWxlIiwiZmlsZUZyb21TeW5jIiwiQmxvYkRhdGFJdGVtIiwic2l6ZSIsImxhc3RNb2RpZmllZCIsIm10aW1lTXMiLCJzdGFydCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInNsaWNlIiwiZW5kIiwic3RyZWFtIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/from.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fetch-blob/index.js":
/*!******************************************!*\
  !*** ./node_modules/fetch-blob/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* binding */ Blob),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _streams_cjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./streams.cjs */ \"(rsc)/./node_modules/fetch-blob/streams.cjs\");\n/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */ // TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n/** @param {(Blob | Uint8Array)[]} parts */ async function* toIterator(parts, clone = true) {\n    for (const part of parts){\n        if (\"stream\" in part) {\n            yield* /** @type {AsyncIterableIterator<Uint8Array>} */ part.stream();\n        } else if (ArrayBuffer.isView(part)) {\n            if (clone) {\n                let position = part.byteOffset;\n                const end = part.byteOffset + part.byteLength;\n                while(position !== end){\n                    const size = Math.min(end - position, POOL_SIZE);\n                    const chunk = part.buffer.slice(position, position + size);\n                    position += chunk.byteLength;\n                    yield new Uint8Array(chunk);\n                }\n            } else {\n                yield part;\n            }\n        /* c8 ignore next 10 */ } else {\n            // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n            let position = 0, b = /** @type {Blob} */ part;\n            while(position !== b.size){\n                const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));\n                const buffer = await chunk.arrayBuffer();\n                position += buffer.byteLength;\n                yield new Uint8Array(buffer);\n            }\n        }\n    }\n}\nconst _Blob = class Blob {\n    /** @type {Array.<(Blob|Uint8Array)>} */ #parts;\n    #type;\n    #size;\n    #endings;\n    /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */ constructor(blobParts = [], options = {}){\n        this.#parts = [];\n        this.#type = \"\";\n        this.#size = 0;\n        this.#endings = \"transparent\";\n        if (typeof blobParts !== \"object\" || blobParts === null) {\n            throw new TypeError(\"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\");\n        }\n        if (typeof blobParts[Symbol.iterator] !== \"function\") {\n            throw new TypeError(\"Failed to construct 'Blob': The object must have a callable @@iterator property.\");\n        }\n        if (typeof options !== \"object\" && typeof options !== \"function\") {\n            throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        }\n        if (options === null) options = {};\n        const encoder = new TextEncoder();\n        for (const element of blobParts){\n            let part;\n            if (ArrayBuffer.isView(element)) {\n                part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n            } else if (element instanceof ArrayBuffer) {\n                part = new Uint8Array(element.slice(0));\n            } else if (element instanceof Blob) {\n                part = element;\n            } else {\n                part = encoder.encode(`${element}`);\n            }\n            this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;\n            this.#parts.push(part);\n        }\n        this.#endings = `${options.endings === undefined ? \"transparent\" : options.endings}`;\n        const type = options.type === undefined ? \"\" : String(options.type);\n        this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : \"\";\n    }\n    /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */ get size() {\n        return this.#size;\n    }\n    /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */ get type() {\n        return this.#type;\n    }\n    /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */ async text() {\n        // More optimized than using this.arrayBuffer()\n        // that requires twice as much ram\n        const decoder = new TextDecoder();\n        let str = \"\";\n        for await (const part of toIterator(this.#parts, false)){\n            str += decoder.decode(part, {\n                stream: true\n            });\n        }\n        // Remaining\n        str += decoder.decode();\n        return str;\n    }\n    /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */ async arrayBuffer() {\n        // Easier way... Just a unnecessary overhead\n        // const view = new Uint8Array(this.size);\n        // await this.stream().getReader({mode: 'byob'}).read(view);\n        // return view.buffer;\n        const data = new Uint8Array(this.size);\n        let offset = 0;\n        for await (const chunk of toIterator(this.#parts, false)){\n            data.set(chunk, offset);\n            offset += chunk.length;\n        }\n        return data.buffer;\n    }\n    stream() {\n        const it = toIterator(this.#parts, true);\n        return new globalThis.ReadableStream({\n            // @ts-ignore\n            type: \"bytes\",\n            async pull (ctrl) {\n                const chunk = await it.next();\n                chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n            },\n            async cancel () {\n                await it.return();\n            }\n        });\n    }\n    /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */ slice(start = 0, end = this.size, type = \"\") {\n        const { size } = this;\n        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const parts = this.#parts;\n        const blobParts = [];\n        let added = 0;\n        for (const part of parts){\n            // don't add the overflow to new blobParts\n            if (added >= span) {\n                break;\n            }\n            const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n            if (relativeStart && size <= relativeStart) {\n                // Skip the beginning and change the relative\n                // start & end position as we skip the unwanted parts\n                relativeStart -= size;\n                relativeEnd -= size;\n            } else {\n                let chunk;\n                if (ArrayBuffer.isView(part)) {\n                    chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n                    added += chunk.byteLength;\n                } else {\n                    chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n                    added += chunk.size;\n                }\n                relativeEnd -= size;\n                blobParts.push(chunk);\n                relativeStart = 0 // All next sequential parts should start at 0\n                ;\n            }\n        }\n        const blob = new Blob([], {\n            type: String(type).toLowerCase()\n        });\n        blob.#size = span;\n        blob.#parts = blobParts;\n        return blob;\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n    static [Symbol.hasInstance](object) {\n        return object && typeof object === \"object\" && typeof object.constructor === \"function\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n    }\n};\nObject.defineProperties(_Blob.prototype, {\n    size: {\n        enumerable: true\n    },\n    type: {\n        enumerable: true\n    },\n    slice: {\n        enumerable: true\n    }\n});\n/** @type {typeof globalThis.Blob} */ const Blob = _Blob;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Blob);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpRkFBaUYsR0FFakYsbUdBQW1HO0FBQ25HLGtEQUFrRDtBQUU1QjtBQUV0QixnRUFBZ0U7QUFDaEUsTUFBTUEsWUFBWTtBQUVsQix5Q0FBeUMsR0FDekMsZ0JBQWlCQyxXQUFZQyxLQUFLLEVBQUVDLFFBQVEsSUFBSTtJQUM5QyxLQUFLLE1BQU1DLFFBQVFGLE1BQU87UUFDeEIsSUFBSSxZQUFZRSxNQUFNO1lBQ3BCLE9BQVMsOENBQThDLEdBQUlBLEtBQUtDLE1BQU07UUFDeEUsT0FBTyxJQUFJQyxZQUFZQyxNQUFNLENBQUNILE9BQU87WUFDbkMsSUFBSUQsT0FBTztnQkFDVCxJQUFJSyxXQUFXSixLQUFLSyxVQUFVO2dCQUM5QixNQUFNQyxNQUFNTixLQUFLSyxVQUFVLEdBQUdMLEtBQUtPLFVBQVU7Z0JBQzdDLE1BQU9ILGFBQWFFLElBQUs7b0JBQ3ZCLE1BQU1FLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0osTUFBTUYsVUFBVVI7b0JBQ3RDLE1BQU1lLFFBQVFYLEtBQUtZLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDVCxVQUFVQSxXQUFXSTtvQkFDckRKLFlBQVlPLE1BQU1KLFVBQVU7b0JBQzVCLE1BQU0sSUFBSU8sV0FBV0g7Z0JBQ3ZCO1lBQ0YsT0FBTztnQkFDTCxNQUFNWDtZQUNSO1FBQ0YscUJBQXFCLEdBQ3JCLE9BQU87WUFDTCwyRUFBMkU7WUFDM0UsSUFBSUksV0FBVyxHQUFHVyxJQUFLLGlCQUFpQixHQUFJZjtZQUM1QyxNQUFPSSxhQUFhVyxFQUFFUCxJQUFJLENBQUU7Z0JBQzFCLE1BQU1HLFFBQVFJLEVBQUVGLEtBQUssQ0FBQ1QsVUFBVUssS0FBS0MsR0FBRyxDQUFDSyxFQUFFUCxJQUFJLEVBQUVKLFdBQVdSO2dCQUM1RCxNQUFNZ0IsU0FBUyxNQUFNRCxNQUFNSyxXQUFXO2dCQUN0Q1osWUFBWVEsT0FBT0wsVUFBVTtnQkFDN0IsTUFBTSxJQUFJTyxXQUFXRjtZQUN2QjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1LLFFBQVEsTUFBTUM7SUFDbEIsc0NBQXNDLEdBQ3RDLENBQUNwQixLQUFLLENBQUs7SUFDWCxDQUFDcUIsSUFBSSxDQUFLO0lBQ1YsQ0FBQ1gsSUFBSSxDQUFJO0lBQ1QsQ0FBQ1ksT0FBTyxDQUFnQjtJQUV4Qjs7Ozs7OztHQU9DLEdBQ0RDLFlBQWFDLFlBQVksRUFBRSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO2FBYjNDLENBQUN6QixLQUFLLEdBQUcsRUFBRTthQUNYLENBQUNxQixJQUFJLEdBQUc7YUFDUixDQUFDWCxJQUFJLEdBQUc7YUFDUixDQUFDWSxPQUFPLEdBQUc7UUFXVCxJQUFJLE9BQU9FLGNBQWMsWUFBWUEsY0FBYyxNQUFNO1lBQ3ZELE1BQU0sSUFBSUUsVUFBVTtRQUN0QjtRQUVBLElBQUksT0FBT0YsU0FBUyxDQUFDRyxPQUFPQyxRQUFRLENBQUMsS0FBSyxZQUFZO1lBQ3BELE1BQU0sSUFBSUYsVUFBVTtRQUN0QjtRQUVBLElBQUksT0FBT0QsWUFBWSxZQUFZLE9BQU9BLFlBQVksWUFBWTtZQUNoRSxNQUFNLElBQUlDLFVBQVU7UUFDdEI7UUFFQSxJQUFJRCxZQUFZLE1BQU1BLFVBQVUsQ0FBQztRQUVqQyxNQUFNSSxVQUFVLElBQUlDO1FBQ3BCLEtBQUssTUFBTUMsV0FBV1AsVUFBVztZQUMvQixJQUFJdEI7WUFDSixJQUFJRSxZQUFZQyxNQUFNLENBQUMwQixVQUFVO2dCQUMvQjdCLE9BQU8sSUFBSWMsV0FBV2UsUUFBUWpCLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDZ0IsUUFBUXhCLFVBQVUsRUFBRXdCLFFBQVF4QixVQUFVLEdBQUd3QixRQUFRdEIsVUFBVTtZQUN4RyxPQUFPLElBQUlzQixtQkFBbUIzQixhQUFhO2dCQUN6Q0YsT0FBTyxJQUFJYyxXQUFXZSxRQUFRaEIsS0FBSyxDQUFDO1lBQ3RDLE9BQU8sSUFBSWdCLG1CQUFtQlgsTUFBTTtnQkFDbENsQixPQUFPNkI7WUFDVCxPQUFPO2dCQUNMN0IsT0FBTzJCLFFBQVFHLE1BQU0sQ0FBQyxDQUFDLEVBQUVELFFBQVEsQ0FBQztZQUNwQztZQUVBLElBQUksQ0FBQyxDQUFDckIsSUFBSSxJQUFJTixZQUFZQyxNQUFNLENBQUNILFFBQVFBLEtBQUtPLFVBQVUsR0FBR1AsS0FBS1EsSUFBSTtZQUNwRSxJQUFJLENBQUMsQ0FBQ1YsS0FBSyxDQUFDaUMsSUFBSSxDQUFDL0I7UUFDbkI7UUFFQSxJQUFJLENBQUMsQ0FBQ29CLE9BQU8sR0FBRyxDQUFDLEVBQUVHLFFBQVFILE9BQU8sS0FBS1ksWUFBWSxnQkFBZ0JULFFBQVFILE9BQU8sQ0FBQyxDQUFDO1FBQ3BGLE1BQU1ELE9BQU9JLFFBQVFKLElBQUksS0FBS2EsWUFBWSxLQUFLQyxPQUFPVixRQUFRSixJQUFJO1FBQ2xFLElBQUksQ0FBQyxDQUFDQSxJQUFJLEdBQUcsaUJBQWlCZSxJQUFJLENBQUNmLFFBQVFBLE9BQU87SUFDcEQ7SUFFQTs7O0dBR0MsR0FDRCxJQUFJWCxPQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtJQUNuQjtJQUVBOztHQUVDLEdBQ0QsSUFBSVcsT0FBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUk7SUFDbkI7SUFFQTs7Ozs7O0dBTUMsR0FDRCxNQUFNZ0IsT0FBUTtRQUNaLCtDQUErQztRQUMvQyxrQ0FBa0M7UUFDbEMsTUFBTUMsVUFBVSxJQUFJQztRQUNwQixJQUFJQyxNQUFNO1FBQ1YsV0FBVyxNQUFNdEMsUUFBUUgsV0FBVyxJQUFJLENBQUMsQ0FBQ0MsS0FBSyxFQUFFLE9BQVE7WUFDdkR3QyxPQUFPRixRQUFRRyxNQUFNLENBQUN2QyxNQUFNO2dCQUFFQyxRQUFRO1lBQUs7UUFDN0M7UUFDQSxZQUFZO1FBQ1pxQyxPQUFPRixRQUFRRyxNQUFNO1FBQ3JCLE9BQU9EO0lBQ1Q7SUFFQTs7Ozs7O0dBTUMsR0FDRCxNQUFNdEIsY0FBZTtRQUNuQiw0Q0FBNEM7UUFDNUMsMENBQTBDO1FBQzFDLDREQUE0RDtRQUM1RCxzQkFBc0I7UUFFdEIsTUFBTXdCLE9BQU8sSUFBSTFCLFdBQVcsSUFBSSxDQUFDTixJQUFJO1FBQ3JDLElBQUlpQyxTQUFTO1FBQ2IsV0FBVyxNQUFNOUIsU0FBU2QsV0FBVyxJQUFJLENBQUMsQ0FBQ0MsS0FBSyxFQUFFLE9BQVE7WUFDeEQwQyxLQUFLRSxHQUFHLENBQUMvQixPQUFPOEI7WUFDaEJBLFVBQVU5QixNQUFNZ0MsTUFBTTtRQUN4QjtRQUVBLE9BQU9ILEtBQUs1QixNQUFNO0lBQ3BCO0lBRUFYLFNBQVU7UUFDUixNQUFNMkMsS0FBSy9DLFdBQVcsSUFBSSxDQUFDLENBQUNDLEtBQUssRUFBRTtRQUVuQyxPQUFPLElBQUkrQyxXQUFXQyxjQUFjLENBQUM7WUFDbkMsYUFBYTtZQUNiM0IsTUFBTTtZQUNOLE1BQU00QixNQUFNQyxJQUFJO2dCQUNkLE1BQU1yQyxRQUFRLE1BQU1pQyxHQUFHSyxJQUFJO2dCQUMzQnRDLE1BQU11QyxJQUFJLEdBQUdGLEtBQUtHLEtBQUssS0FBS0gsS0FBS0ksT0FBTyxDQUFDekMsTUFBTTBDLEtBQUs7WUFDdEQ7WUFFQSxNQUFNQztnQkFDSixNQUFNVixHQUFHVyxNQUFNO1lBQ2pCO1FBQ0Y7SUFDRjtJQUVBOzs7Ozs7OztHQVFDLEdBQ0QxQyxNQUFPMkMsUUFBUSxDQUFDLEVBQUVsRCxNQUFNLElBQUksQ0FBQ0UsSUFBSSxFQUFFVyxPQUFPLEVBQUUsRUFBRTtRQUM1QyxNQUFNLEVBQUVYLElBQUksRUFBRSxHQUFHLElBQUk7UUFFckIsSUFBSWlELGdCQUFnQkQsUUFBUSxJQUFJL0MsS0FBS2lELEdBQUcsQ0FBQ2xELE9BQU9nRCxPQUFPLEtBQUsvQyxLQUFLQyxHQUFHLENBQUM4QyxPQUFPaEQ7UUFDNUUsSUFBSW1ELGNBQWNyRCxNQUFNLElBQUlHLEtBQUtpRCxHQUFHLENBQUNsRCxPQUFPRixLQUFLLEtBQUtHLEtBQUtDLEdBQUcsQ0FBQ0osS0FBS0U7UUFFcEUsTUFBTW9ELE9BQU9uRCxLQUFLaUQsR0FBRyxDQUFDQyxjQUFjRixlQUFlO1FBQ25ELE1BQU0zRCxRQUFRLElBQUksQ0FBQyxDQUFDQSxLQUFLO1FBQ3pCLE1BQU13QixZQUFZLEVBQUU7UUFDcEIsSUFBSXVDLFFBQVE7UUFFWixLQUFLLE1BQU03RCxRQUFRRixNQUFPO1lBQ3hCLDBDQUEwQztZQUMxQyxJQUFJK0QsU0FBU0QsTUFBTTtnQkFDakI7WUFDRjtZQUVBLE1BQU1wRCxPQUFPTixZQUFZQyxNQUFNLENBQUNILFFBQVFBLEtBQUtPLFVBQVUsR0FBR1AsS0FBS1EsSUFBSTtZQUNuRSxJQUFJaUQsaUJBQWlCakQsUUFBUWlELGVBQWU7Z0JBQzFDLDZDQUE2QztnQkFDN0MscURBQXFEO2dCQUNyREEsaUJBQWlCakQ7Z0JBQ2pCbUQsZUFBZW5EO1lBQ2pCLE9BQU87Z0JBQ0wsSUFBSUc7Z0JBQ0osSUFBSVQsWUFBWUMsTUFBTSxDQUFDSCxPQUFPO29CQUM1QlcsUUFBUVgsS0FBSzhELFFBQVEsQ0FBQ0wsZUFBZWhELEtBQUtDLEdBQUcsQ0FBQ0YsTUFBTW1EO29CQUNwREUsU0FBU2xELE1BQU1KLFVBQVU7Z0JBQzNCLE9BQU87b0JBQ0xJLFFBQVFYLEtBQUthLEtBQUssQ0FBQzRDLGVBQWVoRCxLQUFLQyxHQUFHLENBQUNGLE1BQU1tRDtvQkFDakRFLFNBQVNsRCxNQUFNSCxJQUFJO2dCQUNyQjtnQkFDQW1ELGVBQWVuRDtnQkFDZmMsVUFBVVMsSUFBSSxDQUFDcEI7Z0JBQ2Y4QyxnQkFBZ0IsRUFBRSw4Q0FBOEM7O1lBQ2xFO1FBQ0Y7UUFFQSxNQUFNTSxPQUFPLElBQUk3QyxLQUFLLEVBQUUsRUFBRTtZQUFFQyxNQUFNYyxPQUFPZCxNQUFNNkMsV0FBVztRQUFHO1FBQzdERCxLQUFLLENBQUN2RCxJQUFJLEdBQUdvRDtRQUNiRyxLQUFLLENBQUNqRSxLQUFLLEdBQUd3QjtRQUVkLE9BQU95QztJQUNUO0lBRUEsSUFBSSxDQUFDdEMsT0FBT3dDLFdBQVcsQ0FBQyxHQUFJO1FBQzFCLE9BQU87SUFDVDtJQUVBLE9BQU8sQ0FBQ3hDLE9BQU95QyxXQUFXLENBQUMsQ0FBRUMsTUFBTSxFQUFFO1FBQ25DLE9BQ0VBLFVBQ0EsT0FBT0EsV0FBVyxZQUNsQixPQUFPQSxPQUFPOUMsV0FBVyxLQUFLLGNBRTVCLFFBQU84QyxPQUFPbEUsTUFBTSxLQUFLLGNBQ3pCLE9BQU9rRSxPQUFPbkQsV0FBVyxLQUFLLFVBQVMsS0FFekMsZ0JBQWdCa0IsSUFBSSxDQUFDaUMsTUFBTSxDQUFDMUMsT0FBT3dDLFdBQVcsQ0FBQztJQUVuRDtBQUNGO0FBRUFHLE9BQU9DLGdCQUFnQixDQUFDcEQsTUFBTXFELFNBQVMsRUFBRTtJQUN2QzlELE1BQU07UUFBRStELFlBQVk7SUFBSztJQUN6QnBELE1BQU07UUFBRW9ELFlBQVk7SUFBSztJQUN6QjFELE9BQU87UUFBRTBELFlBQVk7SUFBSztBQUM1QjtBQUVBLG1DQUFtQyxHQUM1QixNQUFNckQsT0FBT0QsTUFBSztBQUN6QixpRUFBZUMsSUFBSUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldGNhcC1kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9pbmRleC5qcz8yMGQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBmZXRjaC1ibG9iLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuXG4vLyBUT0RPIChqaW1teXdhcnRpbmcpOiBpbiB0aGUgZmVhdHVyZSB1c2UgY29uZGl0aW9uYWwgbG9hZGluZyB3aXRoIHRvcCBsZXZlbCBhd2FpdCAocmVxdWlyZXMgMTQueClcbi8vIE5vZGUgaGFzIHJlY2VudGx5IGFkZGVkIHdoYXR3ZyBzdHJlYW0gaW50byBjb3JlXG5cbmltcG9ydCAnLi9zdHJlYW1zLmNqcydcblxuLy8gNjQgS2lCIChzYW1lIHNpemUgY2hyb21lIHNsaWNlIHRoZWlycyBibG9iIGludG8gVWludDhhcnJheSdzKVxuY29uc3QgUE9PTF9TSVpFID0gNjU1MzZcblxuLyoqIEBwYXJhbSB7KEJsb2IgfCBVaW50OEFycmF5KVtdfSBwYXJ0cyAqL1xuYXN5bmMgZnVuY3Rpb24gKiB0b0l0ZXJhdG9yIChwYXJ0cywgY2xvbmUgPSB0cnVlKSB7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmICgnc3RyZWFtJyBpbiBwYXJ0KSB7XG4gICAgICB5aWVsZCAqICgvKiogQHR5cGUge0FzeW5jSXRlcmFibGVJdGVyYXRvcjxVaW50OEFycmF5Pn0gKi8gKHBhcnQuc3RyZWFtKCkpKVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpKSB7XG4gICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydC5ieXRlT2Zmc2V0XG4gICAgICAgIGNvbnN0IGVuZCA9IHBhcnQuYnl0ZU9mZnNldCArIHBhcnQuYnl0ZUxlbmd0aFxuICAgICAgICB3aGlsZSAocG9zaXRpb24gIT09IGVuZCkge1xuICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbihlbmQgLSBwb3NpdGlvbiwgUE9PTF9TSVpFKVxuICAgICAgICAgIGNvbnN0IGNodW5rID0gcGFydC5idWZmZXIuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSlcbiAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICAgICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHBhcnRcbiAgICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAxMCAqL1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYmxvYnMgdGhhdCBoYXZlIGFycmF5QnVmZmVyIGJ1dCBubyBzdHJlYW0gbWV0aG9kIChub2RlcyBidWZmZXIuQmxvYilcbiAgICAgIGxldCBwb3NpdGlvbiA9IDAsIGIgPSAoLyoqIEB0eXBlIHtCbG9ifSAqLyAocGFydCkpXG4gICAgICB3aGlsZSAocG9zaXRpb24gIT09IGIuc2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IGIuc2xpY2UocG9zaXRpb24sIE1hdGgubWluKGIuc2l6ZSwgcG9zaXRpb24gKyBQT09MX1NJWkUpKVxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpXG4gICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgX0Jsb2IgPSBjbGFzcyBCbG9iIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48KEJsb2J8VWludDhBcnJheSk+fSAqL1xuICAjcGFydHMgPSBbXVxuICAjdHlwZSA9ICcnXG4gICNzaXplID0gMFxuICAjZW5kaW5ncyA9ICd0cmFuc3BhcmVudCdcblxuICAvKipcbiAgICogVGhlIEJsb2IoKSBjb25zdHJ1Y3RvciByZXR1cm5zIGEgbmV3IEJsb2Igb2JqZWN0LiBUaGUgY29udGVudFxuICAgKiBvZiB0aGUgYmxvYiBjb25zaXN0cyBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdmFsdWVzIGdpdmVuXG4gICAqIGluIHRoZSBwYXJhbWV0ZXIgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYmxvYlBhcnRzXG4gICAqIEBwYXJhbSB7eyB0eXBlPzogc3RyaW5nLCBlbmRpbmdzPzogc3RyaW5nIH19IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGJsb2JQYXJ0cyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGJsb2JQYXJ0cyAhPT0gJ29iamVjdCcgfHwgYmxvYlBhcnRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IFRoZSBwcm92aWRlZCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgc2VxdWVuY2UuJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGJsb2JQYXJ0c1tTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IFRoZSBvYmplY3QgbXVzdCBoYXZlIGEgY2FsbGFibGUgQEBpdGVyYXRvciBwcm9wZXJ0eS4nKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnQmxvYlxcJzogcGFyYW1ldGVyIDIgY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS4nKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cblxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBibG9iUGFydHMpIHtcbiAgICAgIGxldCBwYXJ0XG4gICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGVsZW1lbnQpKSB7XG4gICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShlbGVtZW50LmJ1ZmZlci5zbGljZShlbGVtZW50LmJ5dGVPZmZzZXQsIGVsZW1lbnQuYnl0ZU9mZnNldCArIGVsZW1lbnQuYnl0ZUxlbmd0aCkpXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5zbGljZSgwKSlcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgcGFydCA9IGVsZW1lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQgPSBlbmNvZGVyLmVuY29kZShgJHtlbGVtZW50fWApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI3NpemUgKz0gQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpID8gcGFydC5ieXRlTGVuZ3RoIDogcGFydC5zaXplXG4gICAgICB0aGlzLiNwYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuXG4gICAgdGhpcy4jZW5kaW5ncyA9IGAke29wdGlvbnMuZW5kaW5ncyA9PT0gdW5kZWZpbmVkID8gJ3RyYW5zcGFyZW50JyA6IG9wdGlvbnMuZW5kaW5nc31gXG4gICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcob3B0aW9ucy50eXBlKVxuICAgIHRoaXMuI3R5cGUgPSAvXltcXHgyMC1cXHg3RV0qJC8udGVzdCh0eXBlKSA/IHR5cGUgOiAnJ1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBCbG9iIGludGVyZmFjZSdzIHNpemUgcHJvcGVydHkgcmV0dXJucyB0aGVcbiAgICogc2l6ZSBvZiB0aGUgQmxvYiBpbiBieXRlcy5cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIHByb3BlcnR5IG9mIGEgQmxvYiBvYmplY3QgcmV0dXJucyB0aGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLiN0eXBlXG4gIH1cblxuICAvKipcbiAgICogVGhlIHRleHQoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZlxuICAgKiB0aGUgYmxvYiwgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIHRleHQgKCkge1xuICAgIC8vIE1vcmUgb3B0aW1pemVkIHRoYW4gdXNpbmcgdGhpcy5hcnJheUJ1ZmZlcigpXG4gICAgLy8gdGhhdCByZXF1aXJlcyB0d2ljZSBhcyBtdWNoIHJhbVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIGxldCBzdHIgPSAnJ1xuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCBmYWxzZSkpIHtcbiAgICAgIHN0ciArPSBkZWNvZGVyLmRlY29kZShwYXJ0LCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgIH1cbiAgICAvLyBSZW1haW5pbmdcbiAgICBzdHIgKz0gZGVjb2Rlci5kZWNvZGUoKVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYVxuICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGJsb2IgYXNcbiAgICogYmluYXJ5IGRhdGEgY29udGFpbmVkIGluIGFuIEFycmF5QnVmZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGFzeW5jIGFycmF5QnVmZmVyICgpIHtcbiAgICAvLyBFYXNpZXIgd2F5Li4uIEp1c3QgYSB1bm5lY2Vzc2FyeSBvdmVyaGVhZFxuICAgIC8vIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpO1xuICAgIC8vIGF3YWl0IHRoaXMuc3RyZWFtKCkuZ2V0UmVhZGVyKHttb2RlOiAnYnlvYid9KS5yZWFkKHZpZXcpO1xuICAgIC8vIHJldHVybiB2aWV3LmJ1ZmZlcjtcblxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpXG4gICAgbGV0IG9mZnNldCA9IDBcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIGZhbHNlKSkge1xuICAgICAgZGF0YS5zZXQoY2h1bmssIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5idWZmZXJcbiAgfVxuXG4gIHN0cmVhbSAoKSB7XG4gICAgY29uc3QgaXQgPSB0b0l0ZXJhdG9yKHRoaXMuI3BhcnRzLCB0cnVlKVxuXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICBhc3luYyBwdWxsIChjdHJsKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgaXQubmV4dCgpXG4gICAgICAgIGNodW5rLmRvbmUgPyBjdHJsLmNsb3NlKCkgOiBjdHJsLmVucXVldWUoY2h1bmsudmFsdWUpXG4gICAgICB9LFxuXG4gICAgICBhc3luYyBjYW5jZWwgKCkge1xuICAgICAgICBhd2FpdCBpdC5yZXR1cm4oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVGhlIEJsb2IgaW50ZXJmYWNlJ3Mgc2xpY2UoKSBtZXRob2QgY3JlYXRlcyBhbmQgcmV0dXJucyBhXG4gICAqIG5ldyBCbG9iIG9iamVjdCB3aGljaCBjb250YWlucyBkYXRhIGZyb20gYSBzdWJzZXQgb2YgdGhlXG4gICAqIGJsb2Igb24gd2hpY2ggaXQncyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdXG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLnNpemUsIHR5cGUgPSAnJykge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpc1xuXG4gICAgbGV0IHJlbGF0aXZlU3RhcnQgPSBzdGFydCA8IDAgPyBNYXRoLm1heChzaXplICsgc3RhcnQsIDApIDogTWF0aC5taW4oc3RhcnQsIHNpemUpXG4gICAgbGV0IHJlbGF0aXZlRW5kID0gZW5kIDwgMCA/IE1hdGgubWF4KHNpemUgKyBlbmQsIDApIDogTWF0aC5taW4oZW5kLCBzaXplKVxuXG4gICAgY29uc3Qgc3BhbiA9IE1hdGgubWF4KHJlbGF0aXZlRW5kIC0gcmVsYXRpdmVTdGFydCwgMClcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuI3BhcnRzXG4gICAgY29uc3QgYmxvYlBhcnRzID0gW11cbiAgICBsZXQgYWRkZWQgPSAwXG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIC8vIGRvbid0IGFkZCB0aGUgb3ZlcmZsb3cgdG8gbmV3IGJsb2JQYXJ0c1xuICAgICAgaWYgKGFkZGVkID49IHNwYW4pIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2l6ZSA9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZVxuICAgICAgaWYgKHJlbGF0aXZlU3RhcnQgJiYgc2l6ZSA8PSByZWxhdGl2ZVN0YXJ0KSB7XG4gICAgICAgIC8vIFNraXAgdGhlIGJlZ2lubmluZyBhbmQgY2hhbmdlIHRoZSByZWxhdGl2ZVxuICAgICAgICAvLyBzdGFydCAmIGVuZCBwb3NpdGlvbiBhcyB3ZSBza2lwIHRoZSB1bndhbnRlZCBwYXJ0c1xuICAgICAgICByZWxhdGl2ZVN0YXJ0IC09IHNpemVcbiAgICAgICAgcmVsYXRpdmVFbmQgLT0gc2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNodW5rXG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgICAgICBjaHVuayA9IHBhcnQuc3ViYXJyYXkocmVsYXRpdmVTdGFydCwgTWF0aC5taW4oc2l6ZSwgcmVsYXRpdmVFbmQpKVxuICAgICAgICAgIGFkZGVkICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVuayA9IHBhcnQuc2xpY2UocmVsYXRpdmVTdGFydCwgTWF0aC5taW4oc2l6ZSwgcmVsYXRpdmVFbmQpKVxuICAgICAgICAgIGFkZGVkICs9IGNodW5rLnNpemVcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZUVuZCAtPSBzaXplXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICByZWxhdGl2ZVN0YXJ0ID0gMCAvLyBBbGwgbmV4dCBzZXF1ZW50aWFsIHBhcnRzIHNob3VsZCBzdGFydCBhdCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGU6IFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpIH0pXG4gICAgYmxvYi4jc2l6ZSA9IHNwYW5cbiAgICBibG9iLiNwYXJ0cyA9IGJsb2JQYXJ0c1xuXG4gICAgcmV0dXJuIGJsb2JcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdCbG9iJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nXG4gICAgICApICYmXG4gICAgICAvXihCbG9ifEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSlcbiAgICApXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX0Jsb2IucHJvdG90eXBlLCB7XG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2xpY2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KVxuXG4vKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzLkJsb2J9ICovXG5leHBvcnQgY29uc3QgQmxvYiA9IF9CbG9iXG5leHBvcnQgZGVmYXVsdCBCbG9iXG4iXSwibmFtZXMiOlsiUE9PTF9TSVpFIiwidG9JdGVyYXRvciIsInBhcnRzIiwiY2xvbmUiLCJwYXJ0Iiwic3RyZWFtIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJwb3NpdGlvbiIsImJ5dGVPZmZzZXQiLCJlbmQiLCJieXRlTGVuZ3RoIiwic2l6ZSIsIk1hdGgiLCJtaW4iLCJjaHVuayIsImJ1ZmZlciIsInNsaWNlIiwiVWludDhBcnJheSIsImIiLCJhcnJheUJ1ZmZlciIsIl9CbG9iIiwiQmxvYiIsInR5cGUiLCJlbmRpbmdzIiwiY29uc3RydWN0b3IiLCJibG9iUGFydHMiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbGVtZW50IiwiZW5jb2RlIiwicHVzaCIsInVuZGVmaW5lZCIsIlN0cmluZyIsInRlc3QiLCJ0ZXh0IiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwic3RyIiwiZGVjb2RlIiwiZGF0YSIsIm9mZnNldCIsInNldCIsImxlbmd0aCIsIml0IiwiZ2xvYmFsVGhpcyIsIlJlYWRhYmxlU3RyZWFtIiwicHVsbCIsImN0cmwiLCJuZXh0IiwiZG9uZSIsImNsb3NlIiwiZW5xdWV1ZSIsInZhbHVlIiwiY2FuY2VsIiwicmV0dXJuIiwic3RhcnQiLCJyZWxhdGl2ZVN0YXJ0IiwibWF4IiwicmVsYXRpdmVFbmQiLCJzcGFuIiwiYWRkZWQiLCJzdWJhcnJheSIsImJsb2IiLCJ0b0xvd2VyQ2FzZSIsInRvU3RyaW5nVGFnIiwiaGFzSW5zdGFuY2UiLCJvYmplY3QiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiZW51bWVyYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/index.js\n");

/***/ })

};
;